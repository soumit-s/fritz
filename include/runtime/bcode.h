#pragma once

#include "common.h"

typedef struct fz_bcode_buffer_fragment BcodeBufferFragment;
typedef struct fz_bcode_buffer_iterator BcodeBufferIterator;
typedef struct fz_bcode_buffer BcodeBuffer;

struct fz_bcode_buffer_fragment {
	uint8_t *ptr;
	size_t length;
};

struct fz_bcode_buffer_iterator {
	// The fragment used for storing the fragment info.
	BcodeBufferFragment fragment;
	// Pointer to the next element in the buffer.
	BcodeBufferIterator *prev;
};

// Acts as a bytecode buffer. Used for 
// storing the bytecode generated after the compilation
// process. Internally, it acts as a single linked list.
// The reason behind such a choice is the fact that
// it will mostly be used for storing the 
// generated bytecode(byte arrays). After the 
// compilation process is completed the bytecode will be
// copied from the buffer to a normal byte array. Hence
// BcodeBuffer will be used for temporary storage purposes
// only.
struct fz_bcode_buffer {
	BcodeBufferIterator end;
};

extern void bcode_buffer_init(BcodeBuffer*);
extern void bcode_buffer_destroy(BcodeBuffer*);
extern BcodeBufferIterator* bcode_buffer_end(BcodeBuffer*);
extern void bcode_buffer_append(BcodeBuffer*, const uint8_t*, size_t);

typedef struct fz_bcode Bcode;

struct fz_bcode {
	const uint8_t* buffer;
	size_t length;
};

extern void bcode_buffer_to_bcode(BcodeBuffer*, Bcode*);


typedef struct fz_bcode_meta_data BcodeMetaData;
struct fz_bcode_meta_data {
	
};



#define OPCODE_SIZE 2
#define OPCODE(x, ...) (uint8_t []) {x, ##__VA_ARGS__} 
#define DEFINE_OPCODE(x, y, ...) const uint8_t* OPCODE_##x = (uint8_t []) {y, ##__VA_ARGS__} 
#define DECLARE_OPCODE(x) extern const uint8_t* OPCODE_##x

typedef uint8_t* uint8_t_ptr;

DECLARE_OPCODE(BLOCK_IMPLICIT_START);
DECLARE_OPCODE(BLOCK_IMPLICIT_END);
DECLARE_OPCODE(BLOCK_EXPLICIT_START);
DECLARE_OPCODE(BLOCK_EXPLICIT_END);

DECLARE_OPCODE(ADD);
DECLARE_OPCODE(SUB);
DECLARE_OPCODE(MUL);
DECLARE_OPCODE(DIV);
DECLARE_OPCODE(MOD);

// Instruction: set
// Syntax set <dst(const-id | ref)>
// Pops the value onto the destination <dst>.
DECLARE_OPCODE(SET);

// Instruction: set.scope
// Syntax: set.scope <dst(const-id | ref)>
// It is used to pop the last value on the active stack
// and store inside <dst> (short for destination).
// Here <dst> will be implicitly searched for 
// inside the current scope.
// In other words, it is similar to,
// set scope.<dst>
DECLARE_OPCODE(SET_SCOPE);


// Instruction: get.constant
// Syntax: get.constant <const-id>
// Searches for the constant with the given id in the constant
// pool and then pushes it onto the stack.
DECLARE_OPCODE(GET_CONSTANT);

// Instruction: get.scope
// Syntax: get.scope <const-id>
// Searches for a variable and pushes its value to the stack.
// The variable name must be a string constant id.
DECLARE_OPCODE(GET_SCOPE);

// Instruction: invoke
// Syntax: invoke.constant
// Calls a function with a constant number of parameters that 
// can be estimated at compile-time. 
DECLARE_OPCODE(INVOKE_CONSTANT);

#define INST_TO_OPCODE_MAP \
	X(GET_CONSTANT, "get.constant") \
	X(GET_SCOPE, "get.scope") \
	X(SET, "set") \
	X(SET_SCOPE, "set.scope") \
	X(INVOKE_CONSTANT, "invoke.constant") \
	X(ADD, "add") \
	X(SUB, "sub") \
	X(DIV, "div") \
	X(MUL, "mul") \
	X(MOD, "mod")
